\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename rhythmos.info
@include version.texi
@settitle RhythmOS Reference Manual @value{VERSION}

@c Define a new index for options.
@defcodeindex op
@c Combine everything into one index (arbitrarily chosen to be the
@c concept index).
@syncodeindex op cp
@c %**end of header

@copying
This text is a description of the features that are present in the
@code{RhythmOS} kernel (version @value{VERSION}, @value{UPDATED}).

This is Edition @value{EDITION}, last updated @value{UPDATED}, 
of @cite{RhythmOS Reference Manual}, 
for @code{RhythmOS}, Version @value{VERSION}.

Copyright @copyright{} 2011 Dustin Dorroh (@email{dustindorroh@@gmail.com})

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

@end quotation
@end copying

@dircategory Basics
@direntry
* RhythmOS: (rhythmos).               barebones @sc{unix}-like kernel
@end direntry

@titlepage
@title RhythmOS Reference Manual
@subtitle Reference Documentation for RhythmOS
@subtitle Edition @value{EDITION}, for @code{RhythmOS} Version @value{VERSION}.
@subtitle @value{UPDATED}
@author Dustin Dorroh (@email{dustindorroh@@gmail.com})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents


@ifnottex
@node Top, Overview, (dir), (dir)
@top RhythmOS

This manual is for @code{RhythmOS} (version @value{VERSION}, @value{UPDATED}),
which is a an attempt at a barebones @sc{unix}-like kernel
@end ifnottex

@menu
* Overview::                    General purpose and information.
* Building RhythmOS::                Steps to compile and build RhythmOS.
* Running RhythmOS::                 Steps to run RhythmOS
* Programming the kernel::      
* Multitasking::                Interrupt handling
* Memory::                      Paging and virtual memory
* Dynamic Memory Allocation::   
* System calls::                
* I/O::                         
* Filesystems::                 
* Reporting bugs::              Sending bug reports and feature suggestions.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* RhythmOS Features::                
* Project Workspace::           

Building RhythmOS

* Build Internals::             

Build Internals

* Generate Kernel Image::       
* Generate Filesystem Image::   
* Generate Bootloader Image::   

Programming the kernel

* Assembly::                    
* C::                           

C

* The Run-Time Library::        

@end detailmenu
@end menu

@node Overview, Building RhythmOS, Top, Top
@chapter Overview
@cindex Overview

This manual is for @code{RhythmOS} (version @value{VERSION}, @value{UPDATED}),
which is a an attempt at a barebones @sc{unix}-like kernel.


@menu
* RhythmOS Features::                
* Project Workspace::           
@end menu

@node RhythmOS Features, Project Workspace, Overview, Overview
@subsection RhythmOS Features
@cindex RhythmOS Features

These definitions are used throughout the remainder of this manual.

@c @include features.texi

As of right now this guide is intended to help me rember why I made the
design decisions I did.  Most of those decisions I did reach were
derived from much more important decuments than this.  This document
covers most of the design issues and goals that went into a small
@sc{unix} like kernel. The code base is small enough that I will use
source examples to help convey the topics. I will be putting links to
other examples and projects that helped me. I recommend digging through
other projects’ source as much as possible.


@cindex authors
@cindex Dustin, Dorroh

@node Project Workspace,  , RhythmOS Features, Overview
@subsection Project Workspace
@cindex Project Workspace

The location of your project workspace is up to you, but I strongly
encourage you @strong{not} to pick a system-wide entry such as
@file{/usr} or @file{/usr/local}. Developing in your home folder reduces
the possibly of affecting other users, or @emph{visa versa}, with your
project. To be able to explain and navigate the source tree,
@env{PRJROOT} will corespond to @code{RhythmOS}'s root project
directory.

@cindex PRJROOT
@strong{Example:}
@example
If RhythmOS’s project directory is located in @file{@env{$HOME}}, then
   @env{PRJROOT}=@file{$@env{HOME}/rhythmos}
@end example

From here on all paths will be relative to @env{PRJROOT} unless
otherwise noted.

@strong{Examples:}
@example
 @file{src}=@file{@env{PRJROOT}/src}
 @file{src/libc.c}=@file{@env{PRJROOT}/src/libc.c}
@end example


@node  Building RhythmOS, Running RhythmOS, Overview, Top
@chapter Building RhythmOS
@cindex Building RhythmOS

Change directories to @env{PRJROOT}, @code{RhythmOS}'s project root.
To compile @code{RhythmOS}, type @command{`make'}. To create the root file
system for @code{RhythmOS}, type @command{`make fs'}. To build the
bootloader, type @command{`make boot'}.

@example
$ make
$ make fs
$ make boot
@end example

@menu
* Build Internals::             
@end menu

@node Build Internals,  , Building RhythmOS, Building RhythmOS
@subsection Build Internals
@cindex Build Internals

In order for @code{RhythmOS} to be able to boot properly, three different
binary images are needed (@pxref{Building RhythmOS}). The @emph{images} also
have to be made in a particular order due to the build dependencies,
thus the build process naturally falls into a three step process:

@enumerate
@item
Generate Kernel Image (@pxref{Generate Kernel Image})
@item
Generate Filesystem Image (@pxref{Generate Filesystem Image})
@item
Generate Bootloader Image (@pxref{Generate Bootloader Image})
@end enumerate

@menu
* Generate Kernel Image::       
* Generate Filesystem Image::   
* Generate Bootloader Image::   
@end menu

@node Generate Kernel Image, Generate Filesystem Image, Build Internals, Build Internals
@unnumberedsubsubsec Generate Kernel Image
@cindex Generate Kernel Image

Executing @command{make} compiles individual source (@code{.c}) into
object files (@code{.o}). The linker (@command{ld}) is then used next to
link the object files into one binary
@file{src/kernel.bin}. @xref{Assembly}.


@node Generate Filesystem Image, Generate Bootloader Image, Generate Kernel Image, Build Internals
@unnumberedsubsubsec Generate Filesystem Image
@cindex Generate Filesystem Image


The @command{make fs} target executes the build script
@file{mk_filesystem_image.sh} located in @file{src}, the project's
source directory.

The srcipt @file{mk_filesystem_image.sh} creates empty directories in
the project tree, which will be a staging place for the root files that
will be used by RhythmOS. Next, the programs that will run on the kernel (ie
@command{sh}, @command{ls}, @command{cat}, etc ... ) will be copied to
the appropiate staging directory @footnote{For example binaries will
placed in @file{rootfs/bin} directory on the host machine}. An example
of how rootfs might be structured.

@example
$ tree rootfs/
rootfs/
|-- bin
|   |-- cat
|   |-- find
|   |-- ls
|   |-- pwd
|   `-- sh
|-- etc
`-- usr
@end example

An image, based off of the staging filesystem, is then built up in
memory @footnote{ @emph{See} @file{fstool.c} in the project source to
see how the image is created}. When complete the filesystem image will
be located @file{src/filesystem.img}.

@node Generate Bootloader Image,  , Generate Filesystem Image, Build Internals
@unnumberedsubsubsec Generate Bootloader Image
@cindex Generate Bootloader Image

The @command{`make boot'} target executes the build script
@file{mk_boot_image.sh} located in @file{src}, the project's source
directory.

In order to run the kernel, it’s necessary to use a program called a
boot loader. This is the first thing that runs when a computer starts,
and is responsible for loading the kernel file into memory and
instructing the processor to start executing it. A boot loader is placed
right at the very beginning of a disk, which is where the computer looks
for an operating system as soon as it starts.

The @file{grub.img} is the GRUB image that we will as are
bootloader. First we @file{mk_boot_image.sh} makes sure to delete the
old kernel image and filesystem image from the GRUB image.

@example
$ mdel -i grub.img ::kernel.bin || true
$ mdel -i grub.img ::filesystem.img || true
@end example

Lastly @file{mk_boot_image.sh} writes the kernel image
(@file{kernel.bin}) and filesystem image (@file{kernel.bin}) data to the
GRUB image @file{grub.img}.

@example
$ mcopy -i grub.img kernel.bin :: || exit 1
$ mcopy -i grub.img filesystem.img :: || exit 1
@end example

@node Running RhythmOS, Programming the kernel, Building RhythmOS, Top
@chapter Running RhythmOS

Once the kernel has been copied to the disk image, you can then run it
under qemu using one of the following commands:
@example
@code{qemu -fda src/grub.img}
@code{qemu -daemonize -fda src/grub.img # daemonize qemu}
@code{qemu -monitor stdio -fda src/grub.img # output qemu debug on stdio}
@end example

This same command can also be run through the @command{make} target
@code{run-qemu};
@example
@code{make run-qemu}
@end example

@node Programming the kernel, Multitasking, Running RhythmOS, Top
@chapter Programming the kernel

@menu
* Assembly::                    
* C::                           
@end menu

@node  Assembly, C, Programming the kernel, Programming the kernel
@section Assembly

@example
# Link using @file{link.ld}
$(KERNEL_IMG): $(KERNEL_OBJECTS)
    $(LD) @option{-T} @file{link.ld} @option{-o} $(KERNEL_IMG) $(KERNEL_OBJECTS)
@end example

The @option{-T} option instructs the linker @command{ld} to use the
commands in the script file @file{link.ld}. It specifies the various
segments used by the program. In the file we specify 3 segments:

@itemize
@center
@bullet{@code{.text} - Code segment}

@bullet{@code{.data} - Data segment}

@bullet{@code{.bss} -  Stack segment}
@end itemize

@unnumberedsubsec link.ld source file
@center
@example
@code{OUTPUT_FORMAT("binary")}
@code{ENTRY(start)}
@code{phys = 0x00100000;}
@code{SECTIONS}
@code{@{}
@code{  .text phys : AT(phys) @{}
@code{    code = .;}
@code{    *(.text)}
@code{    *(.rodata)}
@code{    . = ALIGN(4096);}
@code{  @}}
@code{  .data : AT(phys + (data - code))}
@code{  @{}
@code{    data = .;}
@code{    *(.data)}
@code{    . = ALIGN(4096);}
@code{  @}}
@code{  .bss : AT(phys + (bss - code))}
@code{  @{}
@code{    bss = .;}
@code{    *(.bss)}
@code{    . = ALIGN(4096);}
@code{  @}}
@code{ . = ALIGN(4096);}
@code{  end = .;}
@code{@}}
@end example

@node  C,  , Assembly, Programming the kernel
@section C
@cindex C

@menu
* The Run-Time Library::        
@end menu

@node The Run-Time Library,  , C, C
@subsection The Run-Time Library
@cindex RTL
@cindex Run-Time Library
@cindex compiler
@cindex OS
@cindex portable
@cindex kernel

A major part of writing code for your a kernel is getting suckered into
rewriting the @dfn{run-time library}, also known as @code{libc}. This is
because the @dfn{RTL} is the most @acronym{OS} @emph{dependent} part of
the compiler package: the C @acronym{RTL} provides enough functionality
to allow you to write @emph{portable} programs, but the inner workings
of the @acronym{RTL} are @emph{dependent} on the @acronym{OS} in use.

The aim is to replicate the library defined by the @dfn{ISO}
@footnote{International Standardization Organization} C standard because
this will make porting programs to my kernel easier. Writing a
non-standard library will only result in having to re-write any
application your trying to port; not to mention many open source
projects that do conform to these standards will be open for me to use.

@cindex open source


@node  Multitasking, Memory, Programming the kernel, Top
@chapter Multitasking

@node  Memory, Dynamic Memory Allocation, Multitasking, Top
@chapter Memory

@node  Dynamic Memory Allocation, System calls, Memory, Top
@chapter Dynamic Memory Allocation

@node  System calls, I/O, Dynamic Memory Allocation, Top
@chapter System calls

@example
@cartouche
        Source for system calls are located in @file{syscall.c},
@file{fscalls.c}, @file{filedesc.c}, @file{unixproc.c}, @file{pipe.c}.
@end cartouche
@end example

When the interrupt occurs, the CPU switches to kernel mode, and
executes the interrupt handler, which is actually implemented in
assembler within @file{start.s}. This pushes the register values onto
the stack, and then calls the @code{interrupt_handler} function, which is
implemented in @code{C}.  The registers that were put onto the stack are
available as a parameter to this function, as a regs object. The
interrupt handler then calls the @code{syscall} function, which inspects the
registers to determine which system call was requested, and then
dispatches to the appropriate handler function. 

For example the system call @code{write} is implemented by the handler
function @code{syscall_write}. The parameters to the system call may
be accessed by looking at the process's stack. One of the saved
registers is the stack pointer, which the syscall function uses to
determine the location in memory of the parameters, which it then
passes to the handler function. The handler for the system call then
performs whatever actions are necessary, which can include privileged
operations such as writing to any area of memory, since this code runs
in kernel mode. Once the handler function returns, control is passed
backwards along the same path, until it returns to the process that
was previously executing. In some cases, such as the read or exit
system calls, the process may have been killed or suspended. If this
is the case, syscall performs a context switch, so that a different
process will be executed when the interrupt handler returns.

The @code{exit} system call is used by a process to terminate itself. When
this call is made, the @code{kill_process} function is called, and the
handler function returns the special value @code{-ESUSPEND}, indicating to
the syscall dispatching function that the current process is no longer
running, and it should perform a context switch. Processes should
always call @code{exit} as their last action, to indicate the kernel that
they have no more instructions to be executed.

List of all the syscalls RhythmOS has available:
@example
@cartouche
          KERNEL             USER         LOCATION
          -----------------------------------------
          syscall_pipe       pipe         pipe.c
          syscall_getpid     getpid       syscall.c  
          syscall_exit       exit         syscall.c 
          syscall_write      write        syscall.c
          syscall_read       read         syscall.c
          syscall_geterrno   geterrno     syscall.c
          syscall_brk        brk          syscall.c
          syscall_send       send         syscall.c
          syscall_receive    receive      syscall.c
          syscall_kill       kill         syscall.c
          syscall_close      close        filedesc.c
          syscall_dup2       dup2         filedesc.c
          syscall_fork       fork         unixproc.c
          syscall_execve     execve       unixproc.c
          syscall_waitpid    waitpid      unixproc.c
          syscall_stat       stat         fscalls.c
          syscall_open       open         fscalls.c
          syscall_chdir      chdir        fscalls.c
          syscall_getcwd     getcwd       fscalls.c
          syscall_getdent    getdent      fscalls.c
@end cartouche
@end example


@node  I/O, Filesystems, System calls, Top
@chapter I/O

@node  Filesystems, Reporting bugs, I/O, Top
@chapter Filesystems

The contents of the root filesystem must be adequate to @emph{boot}, @emph{restore},
and/or @emph{recover} the system.

@itemize
@bullet{To @emph{boot} a system, enough must be present on the root partition to mount
other filesystems. This includes utilities, configuration, boot loader
information, and other essential start-up data.}

@bullet{For the @emph{recovery} of a system, utilities are needed by the user
to diagnose and reconstruct the damaged system; these utilities need
be present on the root filesystem.}

@bullet{To @emph{restore} a system, those utilities needed to restore from system backups
(on floppy, tape, etc.) must be present on the root filesystem.}
@end itemize

See
@uref{http://www.pathname.com/fhs/pub/fhs-2.3.html#THEROOTFILESYSTEM,
The Root Filesystem Standards} for more a more indepth analysis.

Below is an example of a root filesystem @file{/}. Ones marked with an
asterisk (@key{*}) are currently beind used by @code{RhythmOS}.

@table @code
@item @emph{Rootfs file system structure}

@item @file{/bin}
@key{*} Essential command binaries
@item @file{/boot}
Static files of the boot loader
@item @file{/dev}
Device files
@item @file{/etc}
@key{*} Host-specific system configuration
@item @file{/lib}
Essential shared libraries and kernel modules
@item @file{/media}
Mount point for removeable media
@item @file{/mnt}
Mount point for mounting a filesystem temporarily
@item @file{/opt}
Add-on application software packages
@item @file{/sbin}
Essential system binaries
@item @file{/srv}
Data for services provided by this system
@item @file{/tmp}
Temporary files
@item @file{/usr}
@key{*} Secondary hierarchy
@item @file{/var}
Variable data
@end table



@node  Reporting bugs,  , Filesystems, Top
@chapter Reporting bugs

@cindex bug reporting
@cindex problems
@cindex reporting bugs

To report bugs or suggest enhancements for GNU Hello, please send
electronic mail to @email{dustindorroh@@gmail.com}.

@include gnu.texi

@appendix GNU Free Documentation License

@include fdl.texi

@unnumbered Concept index

@printindex cp

@bye
